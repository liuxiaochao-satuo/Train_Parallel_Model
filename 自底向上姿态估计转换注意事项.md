# 自底向上姿态估计：Labelme转COCO格式注意事项

## 📋 目录
1. [自底向上 vs 自顶向下](#自底向上-vs-自顶向下)
2. [转换注意事项](#转换注意事项)
3. [数据格式要求](#数据格式要求)
4. [常见问题](#常见问题)
5. [转换脚本使用说明](#转换脚本使用说明)

---

## 自底向上 vs 自顶向下

### 自顶向下（Top-Down）方法
```
图像 → 检测人（bounding box） → 对每个人检测关键点
```
- **需要**：bounding box（rectangle）
- **特点**：先检测人，再检测关键点
- **适用**：`labelme2coco_example.py`（原始版本）

### 自底向上（Bottom-Up）方法
```
图像 → 检测所有关键点 → 分组到不同的人
```
- **不需要**：bounding box（可以从关键点计算）
- **需要**：group_id 来标识哪些关键点属于同一个人
- **特点**：先检测关键点，再分组
- **适用**：`labelme2coco_bottomup.py`（新版本）

---

## 转换注意事项

### ⚠️ 重要区别

| 项目 | 原始版本（自顶向下） | 新版本（自底向上） |
|------|-------------------|------------------|
| **输入要求** | 必须有rectangle | 只需要关键点（point） |
| **分组方式** | 通过空间位置匹配 | 通过group_id分组 |
| **bounding box** | 从rectangle提取 | 从关键点自动计算 |
| **可见性** | 固定为2 | 从description字段读取 |
| **分割掩码** | 匹配polygon | 不需要 |

### ✅ 必须满足的条件

1. **group_id必须存在**
   ```json
   {
     "label": "nose",
     "shape_type": "point",
     "group_id": 1,  // ← 必须存在！
     "description": "2",
     "points": [[x, y]]
   }
   ```
   - 每个关键点必须有`group_id`
   - 相同`group_id`的关键点会被分到同一个人
   - 如果没有`group_id`，该关键点会被跳过

2. **关键点标签必须标准**
   ```python
   STANDARD_KEYPOINT_ORDER = [
       "nose", "left_eye", "right_eye", ...
   ]
   ```
   - 标签名称必须与标准列表完全一致（大小写敏感）
   - 不存在的关键点会被填充为`[0, 0, 0]`

3. **可见性字段（description）**
   ```json
   {
     "description": "2"  // "0"=完全遮挡, "1"=遮挡可推测, "2"=清晰可见
   }
   ```
   - 如果缺失，默认使用`2`（清晰可见）
   - 必须是字符串`"0"`、`"1"`或`"2"`

---

## 数据格式要求

### Labelme格式示例（自底向上）

```json
{
  "version": "5.9.1",
  "imagePath": "image.jpg",
  "imageHeight": 480,
  "imageWidth": 640,
  "shapes": [
    {
      "label": "nose",
      "shape_type": "point",
      "group_id": 1,  // ← 第一个人
      "description": "2",
      "points": [[320, 240]]
    },
    {
      "label": "left_eye",
      "shape_type": "point",
      "group_id": 1,  // ← 第一个人
      "description": "2",
      "points": [[310, 230]]
    },
    {
      "label": "nose",
      "shape_type": "point",
      "group_id": 2,  // ← 第二个人
      "description": "2",
      "points": [[500, 300]]
    }
  ]
}
```

### 转换后的COCO格式

```json
{
  "annotations": [
    {
      "id": 0,
      "image_id": 0,
      "category_id": 1,
      "bbox": [280, 200, 100, 100],  // ← 从关键点自动计算
      "area": 10000,
      "iscrowd": 0,
      "num_keypoints": 2,
      "keypoints": [
        320, 240, 2,  // nose
        310, 230, 2,  // left_eye
        0, 0, 0,      // right_eye (不存在)
        ...
      ]
    },
    {
      "id": 1,
      "image_id": 0,
      "category_id": 1,
      "bbox": [460, 260, 100, 100],  // ← 从关键点自动计算
      "area": 10000,
      "iscrowd": 0,
      "num_keypoints": 1,
      "keypoints": [
        0, 0, 0,      // nose (不存在)
        0, 0, 0,      // left_eye (不存在)
        0, 0, 0,      // right_eye (不存在)
        500, 300, 2,  // nose (第二个人)
        ...
      ]
    }
  ]
}
```

---

## 常见问题

### Q1: 如果没有group_id怎么办？

**A**: 脚本会跳过没有group_id的关键点，并显示警告：
```
警告：关键点 nose 没有group_id，将被跳过
```

**解决方案**：
1. 在Labelme中为每个关键点设置group_id
2. 使用`process_labelmejson.py`工具批量处理

### Q2: bounding box是如何计算的？

**A**: 从所有可见关键点（visibility > 0）计算：
```python
# 1. 收集所有可见关键点
visible_points = [所有visibility > 0的关键点]

# 2. 计算边界
x_min = min(所有x坐标)
y_min = min(所有y坐标)
x_max = max(所有x坐标)
y_max = max(所有y坐标)

# 3. 添加10%的padding
padding = 10% * (width或height)

# 4. 生成bbox
bbox = [x_min - padding_x, y_min - padding_y, width + 2*padding_x, height + 2*padding_y]
```

**注意**：如果所有关键点都不可见（visibility = 0），该annotation会被跳过。

### Q3: 关键点顺序必须严格按照标准顺序吗？

**A**: **是的！** COCO格式要求关键点必须按照`categories[].keypoints`定义的顺序排列。

例如，如果定义顺序是：
```python
["nose", "left_eye", "right_eye", ...]
```

那么keypoints数组必须是：
```python
[x_nose, y_nose, v_nose, x_left_eye, y_left_eye, v_left_eye, ...]
```

**解决方案**：使用`process_labelmejson.py`工具对标注文件进行排序。

### Q4: 可以缺少某些关键点吗？

**A**: **可以**，但需要正确处理：
- 缺少的关键点会被填充为`[0, 0, 0]`
- `num_keypoints`会统计可见关键点的数量（visibility > 0）
- 建议：即使被遮挡，也尽量标注（设置visibility = 0或1）

### Q5: 自底向上方法真的不需要bounding box吗？

**A**: 训练时可能不需要，但COCO格式要求每个annotation必须有`bbox`字段。因此：
- 脚本会从关键点自动计算bbox
- 这个bbox主要用于格式兼容性
- 实际训练时，模型可能不使用这个bbox

### Q6: 如何处理多人场景？

**A**: 使用不同的`group_id`：
```json
// 第一个人
{"label": "nose", "group_id": 1, ...}
{"label": "left_eye", "group_id": 1, ...}

// 第二个人
{"label": "nose", "group_id": 2, ...}
{"label": "left_eye", "group_id": 2, ...}
```

每个`group_id`会生成一个独立的annotation。

---

## 转换脚本使用说明

### 1. 准备数据

确保你的Labelme标注文件：
- ✅ 所有关键点都有`group_id`
- ✅ 关键点标签符合标准顺序
- ✅ `description`字段正确（0/1/2）

### 2. 运行转换脚本

```bash
python labelme2coco_bottomup.py
```

脚本会：
- 自动扫描当前目录下的所有`.json`文件
- 按`group_id`分组关键点
- 从关键点计算bounding box
- 生成COCO格式的JSON文件

### 3. 输出文件

```
output_coco/
  └── coco_bottomup.json  # COCO格式的标注文件
```

### 4. 验证结果

```python
from pycocotools.coco import COCO

coco = COCO('output_coco/coco_bottomup.json')
print(f'图像数: {len(coco.imgs)}')
print(f'标注数: {len(coco.anns)}')
```

---

## 关键点对比表

### 原始版本 vs 新版本

| 功能 | 原始版本 | 新版本 |
|------|---------|--------|
| **输入** | rectangle + point + polygon | 只有point |
| **分组** | 空间位置匹配 | group_id分组 |
| **bbox来源** | 从rectangle提取 | 从关键点计算 |
| **可见性** | 固定为2 | 从description读取 |
| **适用场景** | 自顶向下方法 | 自底向上方法 |

### 选择哪个版本？

- **使用原始版本** (`labelme2coco_example.py`) 如果：
  - 你标注了bounding box（rectangle）
  - 使用自顶向下姿态估计方法
  - 需要分割掩码（polygon）

- **使用新版本** (`labelme2coco_bottomup.py`) 如果：
  - 只标注了关键点（point）
  - 使用自底向上姿态估计方法
  - 使用group_id来标识不同的人

---

## 总结

对于自底向上姿态估计，转换时需要注意：

1. ✅ **group_id必须存在** - 用于标识不同的人
2. ✅ **关键点标签必须标准** - 与categories定义一致
3. ✅ **可见性从description读取** - 不是固定值
4. ✅ **bbox自动计算** - 从可见关键点计算
5. ✅ **关键点顺序必须正确** - 按照标准顺序排列

使用`labelme2coco_bottomup.py`脚本可以自动处理这些要求！

